var yS=Object.create;var{getPrototypeOf:CS,defineProperty:q,getOwnPropertyNames:I,getOwnPropertyDescriptor:GS}=Object,B=Object.prototype.hasOwnProperty;var T=($,S,k)=>{k=$!=null?yS(CS($)):{};let z=S||!$||!$.__esModule?q(k,"default",{value:$,enumerable:!0}):k;for(let K of I($))if(!B.call(z,K))q(z,K,{get:()=>$[K],enumerable:!0});return z},A=new WeakMap,HS=($)=>{var S=A.get($),k;if(S)return S;if(S=q({},"__esModule",{value:!0}),$&&typeof $==="object"||typeof $==="function")I($).map((z)=>!B.call(S,z)&&q(S,z,{get:()=>$[z],enumerable:!(k=GS($,z))||k.enumerable}));return A.set($,S),S};var JS=($,S)=>{for(var k in S)q($,k,{get:S[k],enumerable:!0,configurable:!0,set:(z)=>S[k]=()=>z})};var ZS={};JS(ZS,{validatePDF:()=>a,splitPDF:()=>h,setMetadata:()=>kS,rotatePDF:()=>i,resizePDF:()=>ES,removeWatermarks:()=>e,removeAttachments:()=>SS,optimizePDF:()=>O,mergePDFs:()=>l,listPageMode:()=>WS,listPageLayout:()=>MS,getProperties:()=>$S,getPDFInfo:()=>s,extractPages:()=>n,extractImages:()=>u,extractFonts:()=>r,extractAttachments:()=>p,encryptPDF:()=>g,dumpObject:()=>zS,decryptPDF:()=>P,cropPDF:()=>KS,addWatermark:()=>o,addAttachments:()=>t,YqPDF:()=>v});module.exports=HS(ZS);var d=require("child_process");var w=require("node:crypto"),j=require("node:fs"),c=require("node:fs/promises"),F=T(require("node:path")),R=T(require("node:os"));async function J($){try{await c.access($,j.constants.F_OK)}catch{throw new Error(`File not found: ${$}`)}}function f($){if(typeof $==="number")return $.toString();if(typeof $==="string")return $;if(Array.isArray($))return $.join(",");return"1"}function X($=".pdf"){return F.default.join(R.default.tmpdir(),`${w.randomUUID()}${$}`)}async function D($){let S=X();return j.writeFileSync(S,$),S}async function b($){return j.readFileSync($)}function Q($){try{if(j.existsSync($))j.unlinkSync($)}catch{}}var m=require("url"),_=require("node:path"),LS=m.fileURLToPath(import.meta.url),QS=_.dirname(LS),XS=_.resolve(QS,"../binary/yq-pdf-cli");class v{timeout;constructor($=30000){this.timeout=$}async executeCommand($){return new Promise((S)=>{let k=d.spawn(XS,[...$],{stdio:["pipe","pipe","pipe"],timeout:this.timeout}),z="",K="";k.stdout.on("data",(M)=>{z+=M.toString()}),k.stderr.on("data",(M)=>{K+=M.toString()}),k.on("close",(M)=>{if(M!==0){S({success:!1,error:K||`Process exited with code ${M}`});return}try{let E=JSON.parse(z.trim());S(E)}catch{S({success:!0,message:z.trim()})}}),k.on("error",(M)=>{S({success:!1,error:M.message})})})}async encrypt($,S,k,z){let K=null,M=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="string")if(y=S,typeof k==="string")if(z)C=k,U=z;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.userPassword,C=S.ownerPassword,"output"in S)U=S.output;else E=!0;if(E)M=X(),U=M;let H=["encrypt",W,U,y];if(C)H.push(C);let L=await this.executeCommand(H);if(E){if(!L.success)throw new Error(L.error||"yq-pdf: encryption failed");return await b(U)}else return L}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(M)Q(M)}}async decrypt($,S,k){let z=null,K=null,M=!1;try{let E;if(Buffer.isBuffer($))z=await D($),E=z;else await J($),E=$;let W,y;if(typeof S==="string")if(W=S,k)y=k;else M=!0;else if(W=S.password,"output"in S)y=S.output;else M=!0;if(M)K=X(),y=K;let C=["decrypt",E,y,W],U=await this.executeCommand(C);if(M){if(!U.success)throw new Error(U.error||"yq-pdf: decryption failed");return await b(y)}else return U}catch(E){if(M)throw E;return{success:!1,error:E instanceof Error?E.message:"Unknown error"}}finally{if(z)Q(z);if(K)Q(K)}}async merge($,S,...k){try{let z=Array.isArray(S)?S:[S,...k];for(let M of z)await J(M);let K=["merge",$,...z];return await this.executeCommand(K)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async split($,S,k){try{await J($);let z=typeof k==="number"?k:k.span,K=["split",$,S,z.toString()];return await this.executeCommand(K)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async extract($,S,k){try{await J($);let z;if(typeof k==="object"&&"pageRange"in k)z=k.pageRange;else z=f(k);let K=["extract",$,S,z];return await this.executeCommand(K)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async rotate($,S,k,z){let K=null,M=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="number")if(y=S,k)if(z)C=k,U=z;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.rotation,C=S.pageRange,"output"in S)U=S.output;else E=!0;if(E)M=X(),U=M;let H=["rotate",W,U,y.toString()],L=C||"1-";H.push(L);let Z=await this.executeCommand(H);if(E){if(!Z.success)throw new Error(Z.error||"yq-pdf: rotation failed");return await b(U)}else return Z}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(M)Q(M)}}async info($){try{await J($);let S=["info",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async validate($,S){try{await J($);let k;if(typeof S==="string")k=S;else if(S&&"mode"in S)k=S.mode;let z=["validate",$];if(k)z.push(k);return await this.executeCommand(z)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async optimize($,S){let k=null,z=null,K=!1;try{let M;if(Buffer.isBuffer($))k=await D($),M=k;else await J($),M=$;let E;if(!S)K=!0,z=X(),E=z;else if(typeof S==="string")E=S;else E=S.output;let W=["optimize",M,E],y=await this.executeCommand(W);if(K){if(!y.success)throw new Error(y.error||"yq-pdf: optimization failed");return await b(E)}else return y}catch(M){if(K)throw M;return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}finally{if(k)Q(k);if(z)Q(z)}}async watermark($,S,k,z){let K=null,M=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="string")if(y=S,k)if(z)C=k,U=z;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.text,C=S.pageRange,"output"in S)U=S.output;else E=!0;if(E)M=X(),U=M;let H=["watermark",W,U,y],L=C||"1-";H.push(L);let Z=await this.executeCommand(H);if(E){if(!Z.success)throw new Error(Z.error||"yq-pdf: watermarking failed");return await b(U)}else return Z}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(M)Q(M)}}async removeWatermarks($,S={}){let k=null,z=null,K=!S.output;try{let M;if(Buffer.isBuffer($))k=await D($),M=k;else await J($),M=$;let E;if(K)z=X(),E=z;else E=S.output;let W=["remove-watermarks",M,E],y=S.pageRange||"1-";W.push(y);let C=await this.executeCommand(W);if(K){if(!C.success)throw new Error(C.error||"yq-pdf: remove watermarks failed");return await b(E)}else return C}catch(M){if(K)throw M;return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}finally{if(k)Q(k);if(z)Q(z)}}async extractImages($,S,k){try{await J($);let z;if(typeof k==="string")z=k;else if(k&&"pageRange"in k)z=k.pageRange;let K=["extract-images",$,S],M=z||"1-";return K.push(M),await this.executeCommand(K)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async extractFonts($,S,k){try{await J($);let z;if(typeof k==="string")z=k;else if(k&&"pageRange"in k)z=k.pageRange;let K=["extract-fonts",$,S],M=z||"1-";return K.push(M),await this.executeCommand(K)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async extractAttachments($,S){try{await J($);let k=["extract-attachments",$,S];return await this.executeCommand(k)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async addAttachments($,S,k,...z){let K=null,M=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C;if(!S)throw new Error("yq-pdf: at least one attachment path is required");if(typeof S==="string")if(k)y=S,C=Array.isArray(k)?k:[k,...z];else E=!0,M=X(),y=M,C=[S];else if(Array.isArray(S))E=!0,M=X(),y=M,C=S;else{if(y=S.output,!k)throw new Error("yq-pdf: at least one attachment path is required");C=Array.isArray(k)?k:[k,...z]}for(let L of C)await J(L);let U=["add-attachments",W,y,...C],H=await this.executeCommand(U);if(E){if(!H.success)throw new Error(H.error||"yq-pdf: add attachments failed");return await b(y)}else return H}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(M)Q(M)}}async removeAttachments($,S,k){let z=null,K=null,M=!1;try{let E;if(Buffer.isBuffer($))z=await D($),E=z;else await J($),E=$;let W,y=[];if(!S)M=!0,K=X(),W=K;else if(typeof S==="string")if(k!==void 0)W=S,y=k||[];else if(S.includes(".")&&(S.includes("/")||S.includes("\\")))W=S;else M=!0,K=X(),W=K,y=[S];else if(Array.isArray(S))M=!0,K=X(),W=K,y=S;else W=S.output,y=S.fileNames||[];let C=["remove-attachments",E,W,...y],U=await this.executeCommand(C);if(M){if(!U.success)throw new Error(U.error||"yq-pdf: remove attachments failed");return await b(W)}else return U}catch(E){if(M)throw E;return{success:!1,error:E instanceof Error?E.message:"Unknown error"}}finally{if(z)Q(z);if(K)Q(K)}}async setMetadata($,S,k,z,K){let M=null,E=null,W=!1;try{let y;if(Buffer.isBuffer($))M=await D($),y=M;else await J($),y=$;let C,U;if(typeof S==="string"&&(S.includes(".")||S.includes("/")||S.includes("\\"))&&k)if(C=S,typeof k==="string"){if(U=[`title:${k}`],z)U.push(`author:${z}`);if(K)U.push(`subject:${K}`)}else{if(U=[],k.title)U.push(`title:${k.title}`);if(k.author)U.push(`author:${k.author}`);if(k.subject)U.push(`subject:${k.subject}`);if(k.keywords)U.push(`keywords:${k.keywords}`);if(k.creator)U.push(`creator:${k.creator}`);if(k.producer)U.push(`producer:${k.producer}`)}else if(W=!0,E=X(),C=E,typeof S==="string"){if(U=[`title:${S}`],typeof k==="string"){if(U.push(`author:${k}`),z)U.push(`subject:${z}`)}}else{if(U=[],S.title)U.push(`title:${S.title}`);if(S.author)U.push(`author:${S.author}`);if(S.subject)U.push(`subject:${S.subject}`);if(S.keywords)U.push(`keywords:${S.keywords}`);if(S.creator)U.push(`creator:${S.creator}`);if(S.producer)U.push(`producer:${S.producer}`)}let H=["set-metadata",y,C,...U],L=await this.executeCommand(H);if(W){if(!L.success)throw new Error(L.error||"yq-pdf: set metadata failed");return await b(C)}else return L}catch(y){if(W)throw y;return{success:!1,error:y instanceof Error?y.message:"Unknown error"}}finally{if(M)Q(M);if(E)Q(E)}}async properties($){try{await J($);let S=["properties",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async dump($,S){try{await J($);let k=["dump",$,S];return await this.executeCommand(k)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async listPageLayout($){try{await J($);let S=["list-page-layout",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async listPageMode($){try{await J($);let S=["list-page-mode",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async resize($,S,k,z,K){try{await J($);let M,E,W;if(typeof k==="number")M=k,E=z,W=K;else M=k.width,E=k.height,W=k.pageRange;let y=["resize",$,S,M.toString(),E.toString()];if(W)y.push(W);return await this.executeCommand(y)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async resizePDF($,S,k,z){let K=null,M=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U,H;if(typeof S==="number")if(y=S,C=k,z)if(U=z.pageRange,"output"in z)H=z.output;else E=!0;else E=!0;else if(y=S.width,C=S.height,U=S.pageRange,"output"in S)H=S.output;else E=!0;if(E)M=X(),H=M;let L=["resize",W,H,y.toString(),C.toString()],Z=U||"1-";L.push(Z);let V=await this.executeCommand(L);if(E){if(!V.success)throw new Error(V.error||"yq-pdf: resize failed");return await b(H)}else return V}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(M)Q(M)}}async crop($,S,k,z,K,M,E){try{await J($);let W,y,C,U,H;if(typeof k==="number")W=k,y=z,C=K,U=M,H=E;else W=k.x,y=k.y,C=k.width,U=k.height,H=k.pageRange;let L=["crop",$,S,W.toString(),y.toString(),C.toString(),U.toString()],Z=H||"1-";return L.push(Z),await this.executeCommand(L)}catch(W){return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}}async cropPDF($,S,k,z,K,M){let E=null,W=null,y=!1;try{let C;if(Buffer.isBuffer($))E=await D($),C=E;else await J($),C=$;let U,H,L,Z,V,Y;if(typeof S==="number")if(U=S,H=k,L=z,Z=K,M)if(V=M.pageRange,"output"in M)Y=M.output;else y=!0;else y=!0;else if(U=S.x,H=S.y,L=S.width,Z=S.height,V=S.pageRange,"output"in S)Y=S.output;else y=!0;if(y)W=X(),Y=W;let x=["crop",C,Y,U.toString(),H.toString(),L.toString(),Z.toString()],US=V||"1-";x.push(US);let N=await this.executeCommand(x);if(y){if(!N.success)throw new Error(N.error||"yq-pdf: crop failed");return await b(Y)}else return N}catch(C){if(y)throw C;return{success:!1,error:C instanceof Error?C.message:"Unknown error"}}finally{if(E)Q(E);if(W)Q(W)}}}var G=new v,g=G.encrypt.bind(G),P=G.decrypt.bind(G),l=G.merge.bind(G),h=G.split.bind(G),n=G.extract.bind(G),i=G.rotate.bind(G),s=G.info.bind(G),a=G.validate.bind(G),O=G.optimize.bind(G),o=G.watermark.bind(G),e=G.removeWatermarks.bind(G),u=G.extractImages.bind(G),r=G.extractFonts.bind(G),p=G.extractAttachments.bind(G),t=G.addAttachments.bind(G),SS=G.removeAttachments.bind(G),kS=G.setMetadata.bind(G),$S=G.properties.bind(G),zS=G.dump.bind(G),MS=G.listPageLayout.bind(G),WS=G.listPageMode.bind(G),ES=G.resizePDF.bind(G),KS=G.cropPDF.bind(G);
