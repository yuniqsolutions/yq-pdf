import{spawn as f}from"child_process";import{randomUUID as x}from"node:crypto";import{constants as A,existsSync as I,readFileSync as B,unlinkSync as T,writeFileSync as w}from"node:fs";import{access as c}from"node:fs/promises";import F from"node:path";import R from"node:os";async function J($){try{await c($,A.F_OK)}catch{throw new Error(`File not found: ${$}`)}}function v($){if(typeof $==="number")return $.toString();if(typeof $==="string")return $;if(Array.isArray($))return $.join(",");return"1"}function X($=".pdf"){return F.join(R.tmpdir(),`${x()}${$}`)}async function D($){let S=X();return w(S,$),S}async function b($){return B($)}function Q($){try{if(I($))T($)}catch{}}import{fileURLToPath as d}from"url";import{dirname as m,resolve as g}from"node:path";var P=d(import.meta.url),l=m(P),h=g(l,"../binary/yq-pdf-cli");class q{timeout;constructor($=30000){this.timeout=$}async executeCommand($){return new Promise((S)=>{let k=f(h,[...$],{stdio:["pipe","pipe","pipe"],timeout:this.timeout}),M="",K="";k.stdout.on("data",(z)=>{M+=z.toString()}),k.stderr.on("data",(z)=>{K+=z.toString()}),k.on("close",(z)=>{if(z!==0){S({success:!1,error:K||`Process exited with code ${z}`});return}try{let E=JSON.parse(M.trim());S(E)}catch{S({success:!0,message:M.trim()})}}),k.on("error",(z)=>{S({success:!1,error:z.message})})})}async encrypt($,S,k,M){let K=null,z=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="string")if(y=S,typeof k==="string")if(M)C=k,U=M;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.userPassword,C=S.ownerPassword,"output"in S)U=S.output;else E=!0;if(E)z=X(),U=z;let H=["encrypt",W,U,y];if(C)H.push(C);let L=await this.executeCommand(H);if(E){if(!L.success)throw new Error(L.error||"yq-pdf: encryption failed");return await b(U)}else return L}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(z)Q(z)}}async decrypt($,S,k){let M=null,K=null,z=!1;try{let E;if(Buffer.isBuffer($))M=await D($),E=M;else await J($),E=$;let W,y;if(typeof S==="string")if(W=S,k)y=k;else z=!0;else if(W=S.password,"output"in S)y=S.output;else z=!0;if(z)K=X(),y=K;let C=["decrypt",E,y,W],U=await this.executeCommand(C);if(z){if(!U.success)throw new Error(U.error||"yq-pdf: decryption failed");return await b(y)}else return U}catch(E){if(z)throw E;return{success:!1,error:E instanceof Error?E.message:"Unknown error"}}finally{if(M)Q(M);if(K)Q(K)}}async merge($,S,...k){try{let M=Array.isArray(S)?S:[S,...k];for(let z of M)await J(z);let K=["merge",$,...M];return await this.executeCommand(K)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async split($,S,k){try{await J($);let M=typeof k==="number"?k:k.span,K=["split",$,S,M.toString()];return await this.executeCommand(K)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async extract($,S,k){try{await J($);let M;if(typeof k==="object"&&"pageRange"in k)M=k.pageRange;else M=v(k);let K=["extract",$,S,M];return await this.executeCommand(K)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async rotate($,S,k,M){let K=null,z=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="number")if(y=S,k)if(M)C=k,U=M;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.rotation,C=S.pageRange,"output"in S)U=S.output;else E=!0;if(E)z=X(),U=z;let H=["rotate",W,U,y.toString()],L=C||"1-";H.push(L);let Z=await this.executeCommand(H);if(E){if(!Z.success)throw new Error(Z.error||"yq-pdf: rotation failed");return await b(U)}else return Z}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(z)Q(z)}}async info($){try{await J($);let S=["info",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async validate($,S){try{await J($);let k;if(typeof S==="string")k=S;else if(S&&"mode"in S)k=S.mode;let M=["validate",$];if(k)M.push(k);return await this.executeCommand(M)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async optimize($,S){let k=null,M=null,K=!1;try{let z;if(Buffer.isBuffer($))k=await D($),z=k;else await J($),z=$;let E;if(!S)K=!0,M=X(),E=M;else if(typeof S==="string")E=S;else E=S.output;let W=["optimize",z,E],y=await this.executeCommand(W);if(K){if(!y.success)throw new Error(y.error||"yq-pdf: optimization failed");return await b(E)}else return y}catch(z){if(K)throw z;return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}finally{if(k)Q(k);if(M)Q(M)}}async watermark($,S,k,M){let K=null,z=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U;if(typeof S==="string")if(y=S,k)if(M)C=k,U=M;else if(k.includes(".")||k.includes("/")||k.includes("\\"))U=k;else C=k,E=!0;else E=!0;else if(y=S.text,C=S.pageRange,"output"in S)U=S.output;else E=!0;if(E)z=X(),U=z;let H=["watermark",W,U,y],L=C||"1-";H.push(L);let Z=await this.executeCommand(H);if(E){if(!Z.success)throw new Error(Z.error||"yq-pdf: watermarking failed");return await b(U)}else return Z}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(z)Q(z)}}async removeWatermarks($,S={}){let k=null,M=null,K=!S.output;try{let z;if(Buffer.isBuffer($))k=await D($),z=k;else await J($),z=$;let E;if(K)M=X(),E=M;else E=S.output;let W=["remove-watermarks",z,E],y=S.pageRange||"1-";W.push(y);let C=await this.executeCommand(W);if(K){if(!C.success)throw new Error(C.error||"yq-pdf: remove watermarks failed");return await b(E)}else return C}catch(z){if(K)throw z;return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}finally{if(k)Q(k);if(M)Q(M)}}async extractImages($,S,k){try{await J($);let M;if(typeof k==="string")M=k;else if(k&&"pageRange"in k)M=k.pageRange;let K=["extract-images",$,S],z=M||"1-";return K.push(z),await this.executeCommand(K)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async extractFonts($,S,k){try{await J($);let M;if(typeof k==="string")M=k;else if(k&&"pageRange"in k)M=k.pageRange;let K=["extract-fonts",$,S],z=M||"1-";return K.push(z),await this.executeCommand(K)}catch(M){return{success:!1,error:M instanceof Error?M.message:"Unknown error"}}}async extractAttachments($,S){try{await J($);let k=["extract-attachments",$,S];return await this.executeCommand(k)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async addAttachments($,S,k,...M){let K=null,z=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C;if(!S)throw new Error("yq-pdf: at least one attachment path is required");if(typeof S==="string")if(k)y=S,C=Array.isArray(k)?k:[k,...M];else E=!0,z=X(),y=z,C=[S];else if(Array.isArray(S))E=!0,z=X(),y=z,C=S;else{if(y=S.output,!k)throw new Error("yq-pdf: at least one attachment path is required");C=Array.isArray(k)?k:[k,...M]}for(let L of C)await J(L);let U=["add-attachments",W,y,...C],H=await this.executeCommand(U);if(E){if(!H.success)throw new Error(H.error||"yq-pdf: add attachments failed");return await b(y)}else return H}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(z)Q(z)}}async removeAttachments($,S,k){let M=null,K=null,z=!1;try{let E;if(Buffer.isBuffer($))M=await D($),E=M;else await J($),E=$;let W,y=[];if(!S)z=!0,K=X(),W=K;else if(typeof S==="string")if(k!==void 0)W=S,y=k||[];else if(S.includes(".")&&(S.includes("/")||S.includes("\\")))W=S;else z=!0,K=X(),W=K,y=[S];else if(Array.isArray(S))z=!0,K=X(),W=K,y=S;else W=S.output,y=S.fileNames||[];let C=["remove-attachments",E,W,...y],U=await this.executeCommand(C);if(z){if(!U.success)throw new Error(U.error||"yq-pdf: remove attachments failed");return await b(W)}else return U}catch(E){if(z)throw E;return{success:!1,error:E instanceof Error?E.message:"Unknown error"}}finally{if(M)Q(M);if(K)Q(K)}}async setMetadata($,S,k,M,K){let z=null,E=null,W=!1;try{let y;if(Buffer.isBuffer($))z=await D($),y=z;else await J($),y=$;let C,U;if(typeof S==="string"&&(S.includes(".")||S.includes("/")||S.includes("\\"))&&k)if(C=S,typeof k==="string"){if(U=[`title:${k}`],M)U.push(`author:${M}`);if(K)U.push(`subject:${K}`)}else{if(U=[],k.title)U.push(`title:${k.title}`);if(k.author)U.push(`author:${k.author}`);if(k.subject)U.push(`subject:${k.subject}`);if(k.keywords)U.push(`keywords:${k.keywords}`);if(k.creator)U.push(`creator:${k.creator}`);if(k.producer)U.push(`producer:${k.producer}`)}else if(W=!0,E=X(),C=E,typeof S==="string"){if(U=[`title:${S}`],typeof k==="string"){if(U.push(`author:${k}`),M)U.push(`subject:${M}`)}}else{if(U=[],S.title)U.push(`title:${S.title}`);if(S.author)U.push(`author:${S.author}`);if(S.subject)U.push(`subject:${S.subject}`);if(S.keywords)U.push(`keywords:${S.keywords}`);if(S.creator)U.push(`creator:${S.creator}`);if(S.producer)U.push(`producer:${S.producer}`)}let H=["set-metadata",y,C,...U],L=await this.executeCommand(H);if(W){if(!L.success)throw new Error(L.error||"yq-pdf: set metadata failed");return await b(C)}else return L}catch(y){if(W)throw y;return{success:!1,error:y instanceof Error?y.message:"Unknown error"}}finally{if(z)Q(z);if(E)Q(E)}}async properties($){try{await J($);let S=["properties",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async dump($,S){try{await J($);let k=["dump",$,S];return await this.executeCommand(k)}catch(k){return{success:!1,error:k instanceof Error?k.message:"Unknown error"}}}async listPageLayout($){try{await J($);let S=["list-page-layout",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async listPageMode($){try{await J($);let S=["list-page-mode",$];return await this.executeCommand(S)}catch(S){return{success:!1,error:S instanceof Error?S.message:"Unknown error"}}}async resize($,S,k,M,K){try{await J($);let z,E,W;if(typeof k==="number")z=k,E=M,W=K;else z=k.width,E=k.height,W=k.pageRange;let y=["resize",$,S,z.toString(),E.toString()];if(W)y.push(W);return await this.executeCommand(y)}catch(z){return{success:!1,error:z instanceof Error?z.message:"Unknown error"}}}async resizePDF($,S,k,M){let K=null,z=null,E=!1;try{let W;if(Buffer.isBuffer($))K=await D($),W=K;else await J($),W=$;let y,C,U,H;if(typeof S==="number")if(y=S,C=k,M)if(U=M.pageRange,"output"in M)H=M.output;else E=!0;else E=!0;else if(y=S.width,C=S.height,U=S.pageRange,"output"in S)H=S.output;else E=!0;if(E)z=X(),H=z;let L=["resize",W,H,y.toString(),C.toString()],Z=U||"1-";L.push(Z);let j=await this.executeCommand(L);if(E){if(!j.success)throw new Error(j.error||"yq-pdf: resize failed");return await b(H)}else return j}catch(W){if(E)throw W;return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}finally{if(K)Q(K);if(z)Q(z)}}async crop($,S,k,M,K,z,E){try{await J($);let W,y,C,U,H;if(typeof k==="number")W=k,y=M,C=K,U=z,H=E;else W=k.x,y=k.y,C=k.width,U=k.height,H=k.pageRange;let L=["crop",$,S,W.toString(),y.toString(),C.toString(),U.toString()],Z=H||"1-";return L.push(Z),await this.executeCommand(L)}catch(W){return{success:!1,error:W instanceof Error?W.message:"Unknown error"}}}async cropPDF($,S,k,M,K,z){let E=null,W=null,y=!1;try{let C;if(Buffer.isBuffer($))E=await D($),C=E;else await J($),C=$;let U,H,L,Z,j,V;if(typeof S==="number")if(U=S,H=k,L=M,Z=K,z)if(j=z.pageRange,"output"in z)V=z.output;else y=!0;else y=!0;else if(U=S.x,H=S.y,L=S.width,Z=S.height,j=S.pageRange,"output"in S)V=S.output;else y=!0;if(y)W=X(),V=W;let _=["crop",C,V,U.toString(),H.toString(),L.toString(),Z.toString()],N=j||"1-";_.push(N);let Y=await this.executeCommand(_);if(y){if(!Y.success)throw new Error(Y.error||"yq-pdf: crop failed");return await b(V)}else return Y}catch(C){if(y)throw C;return{success:!1,error:C instanceof Error?C.message:"Unknown error"}}finally{if(E)Q(E);if(W)Q(W)}}}var G=new q,n=G.encrypt.bind(G),i=G.decrypt.bind(G),s=G.merge.bind(G),a=G.split.bind(G),O=G.extract.bind(G),o=G.rotate.bind(G),e=G.info.bind(G),u=G.validate.bind(G),r=G.optimize.bind(G),p=G.watermark.bind(G),t=G.removeWatermarks.bind(G),SS=G.extractImages.bind(G),kS=G.extractFonts.bind(G),$S=G.extractAttachments.bind(G),zS=G.addAttachments.bind(G),MS=G.removeAttachments.bind(G),WS=G.setMetadata.bind(G),ES=G.properties.bind(G),KS=G.dump.bind(G),US=G.listPageLayout.bind(G),yS=G.listPageMode.bind(G),CS=G.resizePDF.bind(G),GS=G.cropPDF.bind(G);export{u as validatePDF,a as splitPDF,WS as setMetadata,o as rotatePDF,CS as resizePDF,t as removeWatermarks,MS as removeAttachments,r as optimizePDF,s as mergePDFs,yS as listPageMode,US as listPageLayout,ES as getProperties,e as getPDFInfo,O as extractPages,SS as extractImages,kS as extractFonts,$S as extractAttachments,n as encryptPDF,KS as dumpObject,i as decryptPDF,GS as cropPDF,p as addWatermark,zS as addAttachments,q as YqPDF};
